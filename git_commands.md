<b>Git Bash</b>에서 사용하는 `명령어` 모음
=================================
<b><i>Git</i></b>을 처음 접하는 사람들에게
---------------------------------
> <b><i>Git</i></b>은 리눅스 개발자가 프로젝트를 효율적으로 관리하기 위한 저장소 분산 관리 도구이다. <b>GitHub</b> 뿐 아니라 GitLab, BitBucket 등 원격저장소를 지원하는 여러 플랫폼과 연동하여 사용할 수 있다.  
> <b><i>Git</i></b>은 처음부터 리눅스 개발자의 편의성을 위해 만들었으므로, <b>Git Bash</b>는 Linux의 CLI 환경과 비슷하다고 한다. 그래서 명령 프롬프트처럼 <s>한 줄씩 일일이</s> 명령어로 처리하도록 되어 있다.   
> <b><i>Git</i></b>의 가장 기본적인 기능 중 하나인 **Commit**은 파일의 버전을 저장하고 관리할 수 있게 해준다.   

> [!NOTE]   
> Commit 명령어로 만들어진 '커밋 파일'은 한 번 생성되면 영원히 지워지지 않는다는 것을 항상 명심하자.    
---
## <b><i>Git</i></b> 설치 이후 처음 환경설정

### LINUX 터미널 기본 명령어<sub>(Windows 기준)</sub>
> &#x1F4A1; 명령어를 입력할 때 항상 띄어쓰기와 대소문자를 조심하자.

#### `pwd` 명령어
<q>print working directory</q>. 현재 작업하는 폴더의 경로를 확인하는 명령어이다.   
출력결과: <sup>ex)</sup> <q>/c/Users/user/Documents/</q>

#### `cd` 명령어
<q>change directory</q>. 작업할 폴더 혹은 디렉터리를 변경(이동)하는 명령어이다.
1. `cd c`
    + '내 PC'에서 C 드라이브로 경로를 변경한다. 다른 경로에 있으면 아무것도 바뀌지 않는다.
2. `cd ../`
    + 상대 경로로 이동한다. 상위 폴더로 이동.
3. `cd <dir_name>/[<dir_name>/]`
    + 현재 디렉터리에서 하위 폴더로 쭉 이동한다. 슬래시(/)를 여러 개 쓸 수록 점점 하위 내용에 접근할 수 있게 된다. 폴더 이름을 잘못 입력하면 '해당 디렉터리를 찾을 수 없음' 이라고 뜬다.
4. `cd ~`
    + user 디렉터리(root 경로)에 접근한다. 이 명령 후 `pwd`를 해보면 <q>/c/Users/user/</q> 혹은 <q>/c/Users/admin/</q> 등으로 출력될 것이다.(리눅스에서만 통하는 방식으로 나는 알고 있다.)
5. `cd ../<dir_name>/[<dir_name>/]`
    + 2,3번을 응용해서 상위 폴더의 또 다른 하위 폴더에 접근하는 방식이다. 꽤 자주 쓰는 편이다.

#### `ls` 명령어
특정 디렉터리에 있는 파일과 폴더들을 확인하고 싶을 때 사용한다.
1. `ls`
    + 아무 옵션이 없다면 현재 작업하는 디렉터리의 모든 파일과 폴더를 나열해서 출력한다.
2. `ls -a`
    + 이 옵션은 숨김 파일까지 모두 출력한다는 의미이다. `.git/` 폴더 여부를 확인할 때 쓰일 수 있다. -> `-A` 옵션은 "./", "../"를 제외하고 숨김 파일까지 출력한다.
3. `ls -l`
    + 이 옵션은 각각의 파일과 폴더의 상세정보가 같이 출력된다. `-al`, `-Al` 옵션으로 숨김 파일도 함께 출력할 수 있다.
4. `ls -R`
    + 현재 디렉토리 포함 모든 하위 디렉토리에 있는 파일, 폴더까지 모두 출력된다. <s>(너무 길다)</s>
5. `ls <dir_name>/[<dir_name>/]` | `ls ../[<dir_name>/]`
    + 상대 경로를 같이 설정하면 그 해당 디렉터리에 있는 파일과 폴더들이 출력된다. 2~4번의 옵션도 모두 마지막에 붙여 사용할 수 있다.
#### `mkdir` 명령어
<q>make directory</q>. 현재 위치에 새로운 디렉터리(폴더)를 생성하는 명령어이다. `mkdir test01 test02` 이런 식으로 이름 사이에 띄어쓰기를 넣으면 각 이름의 폴더가 다 같이 생성된다.

#### `rm` 명령어
어떤 파일이나 디렉터리(폴더)를 <b>완전히 삭제</b>할 때 사용하는 명령어이다. 휴지통에 들어가지 않으니 조심히 써야 한다.
1. `rm <file_name>`
    + 특정 파일을 삭제한다.
2. `rm -r`
    + 특정 디렉터리를 삭제한다.
3. `rm -rf`
    + 특정 파일이나 디렉터리를 사용자 권한으로 강제 삭제한다.(rm 옵션 중에 가장 강력하다)

#### `mv` 명령어
어떤 파일을 다른 디렉터리에 이동시키거나 파일명을 바꾸고 싶을 때 사용한다.
1. `mv <file_name> <dir_name>/[<dir_name>/]`
    + 특정 파일을 `ls` 명령어에서 사용하는 모든 디렉터리 경로로 이동시킬 수 있다. "../"가 상위 디렉터리(폴더)라는 것을 기억하면 꽤나 유용할 수 있다.
2. `mv <file_name> <another_name>`
    + 기존 파일명을 다른 파일명으로 바꿀 수 있다. (파일 탐색기의 이름 바꾸기 가능과 똑같다.)

#### `clear` 명령어
Git Bash 등 명령 창이 너무 지저분할 때 깔끔하게 전부 지우고 싶을 때 사용하면 된다. 별도의 옵션은 없다.

### <b><i>Git</i></b> 초기 설정

#### `git config` 명령어
1. `git config --global user.name "<사용자이름>" #중요`
    + 명령어를 입력하고 큰따옴표("")안에 원하는 닉네임을 아무거나 입력한다.
2. `git config --global user.email "<이메일주소>" #필수`
    + 명령어를 입력하고 큰따옴표("") 안에 원격 저장소(깃허브)의 계정으로 사용할 이메일 주소를 입력한다. <br/>(<u>push/pull 명령어와 직접적으로 연결되므로 정확하게 입력하자.</u>)
3. `git config --list`
    + 상위에 입력한 이름과 주소 등의 git에 등록되어 있는 정보 목록이다. 커밋을 등록할 때마다 여기에 있는 <i>`user`</i> 정보들이 함께 기록된다.
4. `git config --global core.editor "code --wait" #선택(추천)`
    + 커밋을 등록하거나 혹은 수정하면서 주로 사용하는 텍스트 편집기를 설정할 수 있다. 개인이 따로 설정하지 않으면 기본값으로 <i>Linux에서 쓰는 vim 에디터</i>가 설정된다. 위의 명령문을 그대로 작성하면 Microsoft의 VSCode(비주얼 스튜디오 코드)로 전환한다. (아쉽게도 이클립스는 아예 전체 경로를 넣어서 추가해야 한다.)
5. `git config --global color.ui auto #선택`
    + Git Bash 명령창의 에디터 색상 테마를 개발자의 입맛에 맞게 설정할 수 있다. 굳이 설정하지 않아도 Git 실행 자체에는 문제가 없으므로 귀찮으면 안 해도 된다.

#### `git init` 명령어
1. `git init`
    + init은 특정 디렉터리에서 처음 브랜치 초기화(Initializing)를 하는 단계이다. `git init` 뒤에 아무 옵션이 없는 이유는 이미 Git을 설치할 때 우리는 `master`라는 기본 브랜치(default branch)를 설정해놓았기 때문이다. 그러면 `(master)`이라는 이름의 브랜치가 하나 나타나면서 `.git/` 폴더도 하나 생성된다. <b><u>이 폴더 안에 우리가 앞으로 Git에서 수행할 거의 대부분 작업이 기록된다.</u></b>
2. `git init -b main`
    + `-b main`은 `init` 뒤에 붙는 옵션 중에 가장 많이 쓰는 옵션이다. 아까 기본 브랜치를 `master`로 설정한다고 했지만 요즘 대부분의 개발자들은 초기 브랜치로 `main`이라는 이름을 더 선호한다고 한다. 물론 여기에서 옵션으로 입력하지 않더라도 설치 과정에서 미리 바꾸는 방법도 있다. 그건 구글에 찾아보면 잘 나오니 참고하길 바란다.
---
> 드디어 기본적인 환경 설정이 끝났다. 앞으로 새로운 장치나 경로에서 환경설정을 바꾸고 싶을 때는 여기서 다시 참고하면 된다.

### <b><i>Git</i></b> 명령어의 도움말 찾기: `git help`
> <b>Git Bash</b>에서는 기본적으로 명령어의 내용을 덜 채운 상태로 엔터를 쳤을 때 `usage:` 뒤에 해당 명령어를 어떻게 사용하는 지 나오는 경우가 많다.   
그래도 내가 원하는 명령어의 사용 방식을 찾고 싶다면 아래 명령어들을 이용해보자.
1. `git help [cmd_name]`
    + 이 명령어는 Git의 특정 명령어에 대해 모든 내용을 찾아보고 싶은 사람들에게 가장 좋은 방법이다. 이미 컴퓨터에 내장된 html 형식의 해당 문서가 웹 브라우저에 나타날 것이다. `git help git`은 git에 포함된 명령어들의 총집합을 볼 수 있다.
2. `git [cmd_name] --help`
    + 1번과 동일한 결과가 나타난다. 모든 git 명령어는 `--help`옵션이 포함된다.
3. `git [cmd_name] -h`
    + help 명령어보다 좀더 간략한 내용을 Bash에서 직접 출력하는 명령어이다. 
## <b><i>Git</i></b> 가장 기초적인 명령어
### <b><i>Git</i></b> 브랜치 및 커밋 생성 방법
> 처음에 환경설정하고 나면 작업 디렉터리에 기본적으로 `main` 혹은 `master`로 브랜치가 하나 생성될 것이다. 만일 아직 아무런 브랜치도 생성되지 않았다면 원하는 디렉터리에 들어가서 `git init`으로 `.git/`폴더를 생성하고 브랜치 이름을 확인하자.  

> 브랜치가 하나라도 생성되었다면 이제 Git의 가장 기본적인 기능들을 사용할 수 있게 된다.   

#### `git branch` 명령어
1. `git branch [-v]`
    + 우선 어떤 브랜치가 생성되었는지 확인해보자. 나중에 커밋이 저장된 후에 해당 명령문에 -v 옵션을 추가하면 현재 브랜치가 가리키는 커밋 위치도 알 수 있다.
2. `git branch <branch_name>`
    + 새로운 브랜치를 생성할 때 커스텀 이름을 넣어준다. 브랜치를 생성하자 마자 `git log`를 확인하면 HEAD가 가리키는 커밋과 동일한 커밋에 위치하는 것을 알 수 있다. 
    + 커밋이 그리 많지 않다면 main|master 브랜치 하나로 무방하니 아직 새로 만들지 않아도 된다.
3. `git switch [-c] <branch_name>`
    + 기존 작업 브랜치(HEAD)에서 현재 존재하는 다른 브랜치로 이동할 때 사용한다. 중간에 -c 옵션을 추가해주면 새로운 이름의 브랜치를 생성하고 동시에 그 브랜치로 이동한다. 브랜치 생성 시에는 항상 기존에 있는 이름들과 중복되지 않게 하는 것이 중요하다.

#### `git status` + `git add` 명령어
> 커밋을 하기 전에 중요한 명령어들이 몇 개 있다. 바로 '워크트리'의 상태를 확인하고 변경하는 명령어들인데 워크트리는 작업 폴더를 의미하는 말이다. 

1. `git status [-s]`
    + 보통 `git init`으로 초기화한 후에 가장 먼저 해보는 명령어이다. 처음에는 일반적으로 <i>work tree clean</i>이라는 결과가 나타나며 `add`나 `reset`, `restore` 등의 명령어로 상태가 다양하게 바뀔 수 있다.
    + `-s` 옵션은 워크트리에 있는 각 파일, 폴더의 상태를 간략하게 1줄씩 출력해주며 모든 파일에 커밋이 완료된 상태라면 아무것도 출력하지 않는다.
2. `git add <file_name> [<file_name>]`
    + `add` 명령어는 디렉터리의 특정한 파일/폴더들을 워크트리에서 스테이지에 복사하는 방식이다. <i><b>Git</b></i>에서 커밋과 관련된 명령어는 대부분 무언가를 복사한다고 생각하면 편하다. <U>심지어 과거의 커밋을 지우는(?) 명령어들도 특수한 경우를 제외하고는 다른 커밋 혹은 객체를 복사하는 방식</u>일 뿐이다. 
    + `git add` 하기 전에 `git status`를 했을 때 <i>Untracked files: </i> 목록에 새로 생성한 파일들이 <span style="color: red">빨간색으로 표시</span>되어 있다면 그 파일들은 스테이지에 복사할 수 있는 상태가 된다. <i>Untracked</i> 상태는 <i><b>Git</b></i> 저장소에서 그 파일은 관여하지 않는다는 의미이다. 이건 앞으로 꽤 중요한 내용이니 기억해두기 바란다. 그 외에 `add` 명령어가 필요한 다른 상태로는 <i>New, Modified, Deleted</i> 등이 있다.
    + `git add textfile1.txt` 라는 방식으로 파일명과 확장자까지 함께 적어주면 해당 파일만 스테이지에 올릴 수 있다. 
    + `git add textfile1.txt textfile2.txt` 이렇게 파일명 여러 개를 띄어쓰기로 구분해주면 여러 파일을 동시에 스테이지에 올리는 명령어가 된다.
3. `git add .`
    + `git add` 뒤에 파일명 대신 도트`.`를 추가하면 <i>Untracked</i> 상태에 있는 모든 파일이 스테이지에 올라간다. 일일이 많은 파일을 입력하고 싶지 않을 때 유용한 방법이다.

#### `git reset` 명령어
1. `git reset` 
    + `reset` 명령어는 크게 3가지 옵션이 있는데 아무런 옵션을 쓰지 않고 실행하면 `--mixed` 옵션이 적용된다. 이 명령어는 `add` 명령어로 스테이지에 올린 파일들을 다시 스테이지에서 내리고 싶을 때(Unstaging) 가장 간단하게 사용할 수 있는 명령어이다. 
    + 생각보다 이 명령어가 안전한 이유는 작업 워크트리(실질적인 파일 경로)에는 내용이 변하지 않기 때문이다. `restore` 등의 다른 명령어들도 비슷한 기능이 있지만 상대적으로 난이도가 높다. 
2. `git reset [<file_name>]` | `git reset <dir_name>/<file_name>]`
    + `reset` 뒤에 현재 디렉터리나 하위 디렉터리에 특정 파일이나 폴더 등을 지정하면 그 파일(폴더)만 스테이지에서 내릴 수 있다. 

#### `git commit` 명령어
> `commit` 명령어는 <i><b>Git</b></i>의 모든 명령어들 중 가장 중요한 기능을 담당한다. 사실 앞으로 쓰게 될 거의 90% 이상의 명령어들이 `commit` 과 `add` 에서 파생된 명령어들이다.   

> &#x1F4A1; 참고로 커밋을 하기 전에 `git status`에 나타나는 상태 중에 <span style="color: green">초록색으로 표시</span>된 상태들만 커밋 내역에 포함할 수 있다.

1. `git commit`
    + 이 명령어에 아무런 옵션을 주지 않으면 `git config`의 `core.editor`에 설정되어 있는 <b>Git Bash</b>의 기본 에디터(보통 vim)가 실행되면서 직접 커밋 메시지와 Description(한국어 모름)을 지정해줄 수 있다. 포커싱 되어있는 첫 줄에만 입력하면 메시지만 지정이 되고 한 줄 띄어서 자세한 커밋 내용을 함께 입력할 수 있다. 자세한 내용을 알고 싶다면 구글에서 찾아보길 바란다. (나는 불편해서 잘 안 쓴다.)
2. `git commit [-m "<commit_message>"]`
    + 이 옵션은 커밋에 메시지를 간단하게 입력하는 방법이다. 개인적으로 1번보다 이 방법을 더 선호하고 많이 사용한다. 만일 1번에서처럼 Description을 같이 입력하고 싶다면 단축키 <b>`[Shift + Enter]`</b>를 두 번 눌러서 그 아래에 입력하면 된다. (물론 마지막에 큰따옴표로 끝내는 것은 중요하다.)
3. `git commit [-a] [-m "<commit_message>"]`
    + 내가 가장 선호하는 옵션 중 하나이다. 스테이지에 올라가지 않은 목록 중에 <i>Untracked</i> 상태를 제외한 모든 상태의 목록들을 대신에 `add` 해주고 동시에 커밋을 지정해주는 명령어이다. 몇 번 써보고 나면 굉장히 편리한 명령어라는 생각이 들 것이다.

#### `git log` 명령어
> `commit`으로 파일의 버전을 안전하게 저장했다면 이제 `log`로 내역을 확인해보자.
1. `git log [-n<number>]`